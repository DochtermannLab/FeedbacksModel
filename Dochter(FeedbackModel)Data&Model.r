library(MCMCglmm);library(ggplot2);library(MASS)

#### Model Function ####

#Sih et al.'s (2015) feedback model combined with Houle's (1991) "y-model"
#Behavior changes over time depending on underlying state. State/energy can be 
#proportionally allocated to behaviors (TO, 1-TO). It's a really simple looping
#function iterating behaviors and state. Could be vectorized but is fast enough as is.

synd.feedback<-function(t=10,n=250,B1.2.S=0,B2.2.S=0,beta=0.75,AC=0,Var=TRUE,aq.var=0.5){
  #t: number of time steps; n: number of individuals; B1.2.S & B2.2.S: feedback of behavior (B_) to state (lambda in model description)
  #the beta argument allows for varying levels of allocation variation (high beta=high variation)
  #AC allows for behavior to be additively increased (i.e. B@t2 = B@t1+x)
  #aq.var is initial stochastic acquisition variation (higher values=high variation)
  #individuals start with random behavioral expression
  #variation in allocation is generated by changing the trade-off (TO) at each time step, 
  #kept same for all individuals. The TO is randomly drawn from a beta distribtuion with properties (beta, beta)
  
  State<-matrix(NA,t,n)
  Behav1<-matrix(NA,t,n)
  Behav2<-matrix(NA,t,n)
  
  if(Var==FALSE){
    State[1,]<-rep(1,n)
  }else{
    State[1,]<-rnorm(n,1,aq.var)
  }
  
  Behav1[1,]<-rnorm(n,1,.5)
  Behav2[1,]<-rnorm(n,1,.5)
  
  for(i in 2:t){
    #feedbacks between behaviors and state continue for "t" timesteps
    TO<-rbeta(n,beta,beta)
    State[i,]<-State[i-1,]+B1.2.S*Behav1[i-1,]+B2.2.S*Behav2[i-1,]+rnorm(n,0,0.1*abs(State[i-1,]))
    Behav1[i,]<-AC*Behav1[i-1,]+TO*State[i-1,]+rnorm(n,0,0.1*abs(State[i-1,]))
    Behav2[i,]<-AC*Behav2[i-1,]+(1-TO)*State[i-1,]+rnorm(n,0,0.1*abs(State[i-1,]))
  }
  sim.data<-as.data.frame(cbind(rep(1:n,each=t),c(State),c(Behav1),c(Behav2)))
  names(sim.data)<-c("ID","State","Behav1","Behav2")
  invisible(sim.data)
}

#### Figure 2 from manuscript ####
# Brommer & Class (2017) Data and single plot
#replace with own path # BrommerData <- read.csv("C:/Users/neddo/Dropbox/Working/Projects/IntegratedPlasticity/BrommerData.csv")
ggplotColours <- function(n = 6, h = c(0, 360) + 15){
  hcl(h = (seq(h[1], h[2], length = n)), c = 100, l = 65)}

class.cols<-data.frame(Class=levels(as.factor(BrommerData$Class)),
                       color = I(ggplotColours(nlevels(as.factor(BrommerData$Class)) ))   )

par(pty='s',mfrow=c(1,1))
plot(NA,xlim=c(-.1,1),ylim=c(-.1,1), cex=1.5,cex.lab=1.5,cex.axis=1.25,
     xlab=c(expression('within-individual correlation, r'['W'])),
     ylab=c(expression('among-individual correlation, r'['A'])))
abline(a=0,b=1,lty=2)
points(BrommerData$residual,BrommerData$between,pch=16,cex=2.5,
       col=adjustcolor(class.cols$color[match(BrommerData$Class, class.cols$Class)],alpha.f=0.7))

# Dochter (2011) Data and single plot
#replace with own path # corrs <- read.csv("C:/Users/neddo/Dropbox/Working/Projects/IntegratedPlasticity/Dochter(2011).csv")
plot(NA,xlim=c(-1,1),ylim=c(-1,1), cex=1.5,cex.lab=1.5,cex.axis=1.25,
     xlab=c(expression('within-individual correlation, r'['W'])),
     ylab=c(expression('genetic correlation, r'['G'])))
abline(a=0,b=1,lty=2)
points(corrs$r_resid,corrs$r_gen,pch=16,cex=2.5,
       col=adjustcolor(class.cols$color[match(corrs$Class, class.cols$Class)],alpha.f=0.7))

# Figure 2 (Brommer & Class + Dochtermann) 
par(mfrow=c(2,1))
plot(NA,xlim=c(-1,1),ylim=c(-1,1), cex=1.5,cex.lab=1.5,cex.axis=1.25,
     xlab=" ",
     ylab=c(expression('among-individual \ncorrelation, r'['A'])))
abline(a=0,b=1,lty=2)
points(BrommerData$residual,BrommerData$between,pch=16,cex=2.5,
       col=adjustcolor(class.cols$color[match(BrommerData$Class, class.cols$Class)],alpha.f=0.7))

plot(NA,xlim=c(-1,1),ylim=c(-1,1), cex=1.5,cex.lab=1.5,cex.axis=1.25,
     xlab=c(expression('within-individual correlation, r'['W'])),
     ylab=c(expression('genetic correlation, r'['G'])))
abline(a=0,b=1,lty=2)
points(corrs$r_resid,corrs$r_gen,pch=16,cex=2.5,
       col=adjustcolor(class.cols$color[match(corrs$Class, class.cols$Class)],alpha.f=0.7))

#### Simulations & Analysis ####
# Analysis details
prior.tri<-list(G=list(G1=list(V=diag(3),nu=4)),
                R=list(V=diag(3),nu=4)) #this prior is flat for correlations, the focus here
NITT=13000;THIN=10;BURN=3000; multi=2 #MCMCglmm parameters

# Feedback Gradient Simulation & Analysis #
#'sims' simulations are run with populations of 'n' individuals
#This number of simulations is run for each of the levels of feedbacks in 'steps'

sims<-100;steps<-c(-1,-.5,0,.5,1);n=250 #simulation parameters
stor<-matrix(NA,sims*length(steps),3)   #analysis storage
counter<-0  #for storage indexing
for(i in steps){
  for(j in 1:sims){
    counter<-counter+1
    sim.dat<-synd.feedback(n=n,beta=0.5,B1.2.S = i,B2.2.S = i) #data for 'n' individuals is generated
    m1<-MCMCglmm(cbind(State,Behav1,Behav2)~(trait-1),
             random=~us(trait):ID,rcov=~us(trait):units,
             prior=prior.tri,family=rep("gaussian",3),
             nitt=NITT*multi,thin=THIN*multi,burnin=BURN*multi,
             verbose=F,data=sim.dat) #analysis of simulated data for calculation of among- and within-individual correlations
    stor[counter,1]<-i
stor[counter,2]<-round(matrix(posterior.mode(posterior.cor(m1$VCV[,1:9])),3),2)[6] #among-individual correlation
stor[counter,3]<-round(matrix(posterior.mode(posterior.cor(m1$VCV[,10:18])),3),2)[6] #within-individual correlation
    
  }
}
stor<-as.data.frame(stor)

stor2<-melt(stor,measure.vars=c("rA","rW")) #transform to facilitate plotting

#### Figure 3 from manuscript ####
GradientPlot<-ggplot(stor2, aes(y = value, x = x,group=variable,color=variable,shape=variable)) +
  geom_point()+geom_smooth() + 
  xlab(expression(paste("Magnitude of Feedback (",lambda[1],"=",lambda[2],")"))) +
  ylab(bquote('Correlation')) +
  scale_color_discrete(name="  ",breaks=c("rA", "rW"),
                       labels=c(expression(paste(r[A])), expression(paste(r[W]))))+
  scale_shape_discrete(name="  ",breaks=c("rA", "rW"),
                       labels=c(expression(paste(r[A])), expression(paste(r[W]))))+
  guides(color=guide_legend(override.aes=list(fill=NA)))+
  theme_bw()+ 
  theme(axis.title.x = element_text(size = 22), axis.text.x = element_text(size = 18),
        axis.title.y = element_text(size = 22),axis.text.y = element_text(size = 18),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        legend.justification=c(-.25,-.25), legend.position=c(0,0),
        legend.text = element_text(size = 18))+
  theme(aspect.ratio=1)
GradientPlot

#save.image("C:/Users/neddo/Dropbox/Working/Projects/IntegratedPlasticity/feedback_gradient.RData")